# -*- coding: utf-8 -*-
"""NSEStockPrediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X8aLqfeOysrK1ShUicu21jQo9gZmRz0v
"""

# importing the necessary libraries
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import numpy as np

# My NSEStookPrediction is the custom class.
class NSEStockPrediction:
  # Initializer  

  def __init__(self):
    self.X_data = []
    self.X = []
    self.y = []
    self.X_train = []
    self.y_train = []
    self.X_test = []
    self.y_test = []
    self.y_predict = []
    self.time_series_steps = 3

  # method to set time series data to superwised data
  # parameters: 
  # data : raw data we get from user
  # input_steps : number of inputs in time series data
  # output_steps : number of output steps in time series data
  def time_series_data(self, data, input_steps, output_steps=1):
    # initializing two arrays to save input and output
    X,y = [],[]
    
    # loop to populate two arrays by number of features = input_steps, and number of output = output_steps
    for i in range(input_steps,len(data)):
      if i+output_steps > len(data):
        break;
      X.append(data[i-input_steps: i])
      y.append(data[i:i+output_steps])

    return np.array(X).reshape(-1,input_steps), np.array(y)

  # method to initiate the project
  # parameters:
  # data : raw data we get from user
  # ohlc_input : dataType 'String' : 'Open' | 'Close' | 'High' | 'Low'
  # time_series_steps : number of inputs in time series data
  # time_series_output_steps : number of output steps in time series data
  # test_size : test data size need to provide while accessing the train test split module
  def initProject(self, data, ohlc_input, time_series_steps, time_series_output_steps, test_size):
    # generating data using sliding window
    self.X_data = np.array(data[ohlc_input])
    self.time_series_steps = time_series_steps
    X,y = self.time_series_data(np.array(data[ohlc_input]),time_series_steps,time_series_output_steps)
    self.X = X
    self.y = y
    self.data = data
    self.ohlc_input = ohlc_input
    # spliting the data
    self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(X, y, test_size=test_size, random_state=42)
    return (self.X_train, self.X_test, self.y_train, self.y_test)

  # method to initiate the random forest algorithm
  # parameters:
  # n_estimators : parameter needed to access sklearn 
  # random_state : parameter needed to access sklearn 
  def initRandomForestRegressor(self, n_estimators=100, random_state=0):
    # initializing random forest
    rfg = RandomForestRegressor(n_estimators=n_estimators, random_state=random_state)
    # fitting the model
    rfg.fit(self.X_train,self.y_train)
    # predicting the value of whole X
    return rfg

  # method to retrive y predict from main data X
  def getTestYpredict(self,rfg):
    y_predict = rfg.predict(self.X)
    self.y_predict = y_predict
    return y_predict
  
  # method to get score
  def getScore(self, rfg):
    # score 
    print(rfg.score(self.X_test,self.y_test))
    return rfg.score(self.X_test, self.y_test)

  # method to plot data
  def plotTheData(self):
    # ploting the graph
    plt.figure(figsize=(25,9))
    plt.plot(self.data.index[self.time_series_steps:], self.y,marker="", markersize=30,label='Open price')
    plt.plot(self.data.index[self.time_series_steps:],self.y_predict,label='Open price')
    
  # method to retrieve baseline error and prediction error
  def getErrorRates(self):
    X_First = self.X_data[0:len(self.X_data)-1]
    X_Last = self.X_data[1:len(self.X_data)]
    X_Diff=X_First-X_Last
    X_Square=X_Diff*X_Diff
    X_Square_Sum=np.sum([X_Square])
    X_SQroot=np.sqrt(X_Square_Sum)

    y_First = self.y_predict[0:len(self.y_predict)-1]
    y_Last = self.y_predict[1:len(self.y_predict)]
    y_Diff=y_First-y_Last
    y_Square=y_Diff*y_Diff
    y_Square_Sum=np.sum([y_Square])
    y_SQroot=np.sqrt(y_Square_Sum)
    return {'baselineError':X_SQroot, 'predictionError':y_SQroot}

  # method to predict the next day price
  def predict(self,data,rfg):
    result = rfg.predict(np.array(data).reshape(-1,self.time_series_steps))
    return result